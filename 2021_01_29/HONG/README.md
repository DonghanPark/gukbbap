BOJ 11053번 가장 긴 증가하는 부분 수열
<img src="https://i.ibb.co/7KkwjXg/image.png" alt="image" border="0">

문제 접근
---
주어지는 수열의 가장 긴 부분 수열의 길이를 출력하는 문제이다.

부분 수열이란, 
> 주어진 수열의 **일부 항**을 원래 **순서대로** 나열하여 얻을 수 있는 수열

예를 들면 A = {10, 20, 10, 30, 20, 50} 가 주어졌을 때,
순서를 유지하는 {10,20} {20,10,50} {20,30}과 같은 부분적인 집합들이다.

그중 A에서 증가하면서 가장 큰 수열은 {10,20,30,50} 이므로 길이 4를 출력하는 것이다.

#### 1. 완전탐색의 경우

완전 탐색의 경우를 생각해보자.

모든 경우의 부분수열을 찾아야 하므로, 모든 원소가 시작점으로 잡아 볼 수 있다.
시작 점을 잡고, 자신보다 높은 인덱스를 순회하며 해당 값보다 큰 인덱스의 수들을 따로 저장하여 수열을 만든다.

그리고는 저장한 수열에서 다시 시작 점을 잡고, 배열을 순회하며 자신보다 큰 값을 찾는 식의 재귀호출 될 때마다 1식 더해준다면, 첫 for문에서 잡은 원소를 시작 점으로 잡았을 때의 최장증가수열을 알 수 있다.

이를 pesudo 코드로 짜보면
```cpp
function lis(arr)
    maxlen = 0

    if(arr.empty) 
        return 0;

    for(i = 0 to arr.size)
        temp = 0

        for(j = i+1 to arr.size)
            if(arr[i] < arr[j])
                temp.push_back(arr[j])

        maxlen = max(maxlen, lis(arr) + 1)

    return maxlen
```

i를 시작점으로, j는 수열을 돌면서 i보다 뒤에 있고, 값이 큰 원소를 temp에 저장한다.

모아진 temp수열은 기존 i를 앞에 둔 부분수열의,i+1번째 원소가 될 수 있는 수들의 집합이므로 temp를 재귀. 결국 base case인 arr.empty 에 닿으면 올라간다.

maxlen에 가장 큰 증가부분수열을 저장 후 리턴

---
확실하지만, 모든 수에 대해 모든 다른 수를 비교해가며 재귀해나가기 때문에 엄청나게 비효율적일 것이다. 찾아보니 시간 복잡도는 O(2^N)인 미친 성능을 보여준다.

#### 2. 동적계획법 DP를 이용한 경우

- **Memoization - Topdown**

완전탐색의 아이디어에서 힌트를 얻어 메모이제이션을 이용한 동적계획법을 사용하여 lis 함수를 세워 볼 수 있다.

완전 탐색에서는 큰 수 를